---
layout: default
title: 7. 웹 계층 개발
parent: 실전! 스프링부트와 JPA 활용1
---

# 7. 웹 계층 개발
{: .no_toc }

1. TOC
{:toc}

## 홈 화면과 레이아웃

- 렌더링할 뷰(`html`)를 찾는다
  - 반환한 문자(`home`)와 스프링부트 설정 `prefix`, `suffix` 정보 사용

## 회원 등록

- 화면 계층과 서비스 계층을 명확하게 분리한다
  - 폼 객체 사용

## 회원 목록 조회

### 폼 객체 vs 엔티티 직접 사용

- 요구사항이 단순할 때
  - 폼 객체(`MemberForm`) 없이 엔티티(`Member`)를 직접 등록, 수정, 사용해도 무방
- 요구사항이 복잡해지기 시작
  - 엔티티에 화면을 처리하기 위한 기능이 점점 증가
    - 점점 화면에 종속적으로 변함 -> 유지보수하기 어렵다
  - **엔티티는 핵심 비즈니스 로직만 가지고 있고, 화면을 위한 로직은 없어야 한다**
    - 화면이나 API에 맞는 폼 객체나 DTO를 사용
      - 화면이나 API 요구사항은 이것들로 처리
    - 엔티티는 최대한 순수하게 유지

## 상품 수정

- 상품 수정 폼에서 정보 수정 후 Submit 버튼 클릭
- `/items/{itemId}/edit` URL을 POST 방식으로 요청
- `updateItem()` 메서드를 실행
- **컨트롤러에 파라미터로 넘어온** `item` 엔티티 인스턴스는 **현재 준영속 상태**
  - 영속성 컨텍스트의 지원을 받을 수 없음
  - 데이터를 수정해도 **변경 감지 기능은 동작 X**

## **변경 감지와 병합(merge)**

- 준영속 엔티티
  - 영속성 컨텍스트가 더이상 관리하지 않는 엔티티
    - 기존 식별자는 존재?
- **준영속 엔티티를 수정하는 2가지 방법**
  - 변경 감지(Dirty Checking)
    - 영속성 컨텍스트에서 엔티티를 다시 조회한 후에 데이터를 수정
    - 트랜잭션 커밋 시점에 변경 감지 동작 -> UPDATE SQL 수행
  - 병합(Merge)
    - merge()를 실행
    - 파라미터로 넘어온 준영속 엔티티의 식별자 값으로 1차 캐시에서 엔티티를 조회
      - 만약 1차 캐시에 엔티티가 없으면 데이터베이스에서 엔티티를 조회하고 1차 캐시에 저장
    - 조회한 영속 엔티티(`mergeMember`)에 `member` 엔티티의 값을 채워 넣는다
    - 영속 상태인 mergeMember를 반환
    - **정리**
      - 준영속 엔티티의 식별자 값으로 영속 엔티티를 조회
      - 영속 엔티티의 값을 준영속 엔티티의 값으로 모두 교체(병합)
      - 트랜잭션 커밋 시점에 변경 감지 동작 -> UPDATE SQL 실행

{: .warning}
**변경 감지** 기능을 사용하면 **원하는 속성만 선택**해서 변경  
**병합**을 사용하면 **모든 속성이 변경**  
**병합시 값이 없으면** `null`로 업데이트 할 위험도 있다 (병합은 모든 필드를 교체한다)

```java
@Repository
public class ItemRepository {
    
    @PersistenceContext
    EntityManager em;
    
    public void save(Item item) {
        if (item.getId() == null) {
            em.persist(item);
        } else {
            em.merge(item);
        }
    }
    //...
}
```

- 식별자 값이 없으면(`null`)
  - 새로운 엔티티로 판단 -> 영속화(persist)
- 식별자가 있으면
  - 병합(merge)
- 지금처럼 준영속 상태인 상품 엔티티를 수정할 때는
  - `id` 값이 있으므로 병합 수행
- **새로운 엔티티 저장과 준영속 엔티티 병합을 한번에 처리**

## 상품 주문

- 

## 주문 목록 검색, 취소

- 
