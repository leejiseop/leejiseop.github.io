---
layout: default
title: 섹션 9
parent: 자바 ORM 표준 JPA 프로그래밍 - 기본편
---

# 섹션 9
{: .no_toc }

1. TOC
{:toc}

## 프록시

- em.find : DB를 통해서 실제 엔티티 객체 조회
- em.getReference() : DB 조회를 미루는 **가짜(프록시)** 엔티티 객체 조회  
  ex) hellojpa.Member**\$HibernateProxy\$ttLMHZRq** (실제 사용될 때 쿼리가 나간다)

실제 엔티티를 상속받아서 껍데기는 같은데 속은 비어있는 프록시 객체
실제 객체의 참조(target)를 보관한다
조회 -> target 비어있음 -> 영속성 컨텍스트로 초기화 요청 -> DB조회 -> 실제 엔티티 생성 -> 프록시의 target과 연결 -> 값 반환  
초기화? DB를 통해서 진짜 값을 가져와서 진짜 엔티티를 만들어내는 과정. 한 번만 한다  
프록시 객체가 실제 엔티티로 대체되는게 아니라, **프록시 객체를 통해서 실제 엔티티에 접근**하는것이다.  
프록시 객체는 원본 엔티티를 상속받는다. **타입 체크시 ==이 아닌 instance of를 사용해야함**  
영속성 컨텍스트에 찾는 엔티티가 이미 있으면 getReference 호출해도 프록시 객체 대신 실제 엔티티 반환
애초에 프록시든 실제 객체든 상관없이 한 영속성 컨텍스트 안에서 가져온거고 PK가 같으면 == 비교해도 true를 반환한다. 그게 JPA의 기본 정책. 한 트랙잭션 안에서는 같은걸 보장해준다
같은 이유로 영속성 컨텍스트에 이미 프록시 객체가 있으면, 이후에 em.find로 조회해도 프록시 객체를 반환해준다. ==을 보장해야하기 때문.
- 영속성 컨텍스트의 도움을 받을 수 없는 **준영속 상태**일 때 프록시를 초기화하면 문제가 발생한다.
프록시 인스턴스 초기화 여부 확인 `emf.getPersistenceUnitUtil().isLoaded(refMember)`
프록시 강제 초기화 `Hibernate.initialize(refMember)` (JPA 표준은 강제 초기화 제공 X)



## 즉시 로딩과 지연 로딩

## 영속성 전이: CASCADE

## 고아 객체와 생명주기