---
layout: default
title: 7. 가상메모리
parent: OS
---

# 가상메모리
{: .no_toc }

1. TOC
{:toc}

### 섹션7 가상메모리

- 메모리보다 큰 프로그램을 실행 가능하게 해준다
- 프로그래머는 물리메모리의 크기와 메모리가 어느위치에 올라가는지 신경쓰지 않고 0번지에서 시작한다 생각하고 프로그래밍이 가능해진다
- 프로세스는 메모리 관리자를 통해 메모리로 접근한다

- 가상메모리는 이론상으로 무한대지만, 실제로는 **물리메모리 크기와 CPU의 비트수로 결정**된다.
  - 32bit인 경우, 표현 가능 주소값은 최대 2의 32승 (대략 4GB)
  - 가상메모리도 마찬가지로 대략 4GB
- 동적주소변환 = 메모리 관리자가 메모리 + 하드디스크 스왑영역을 합쳐서 주소를 다루는 것 (가상주소를 물리주소로 변환)
  - 가상주소와 물리주소를 1:1 매핑으로 관리(매핑 테이블)
    - 프로세스 A -> 세그먼트 0
    - 프로세스 B -> 세그먼트 1
    - 프로세스 C -> 스왑영역
- 물리 메모리를 어떻게 나눌지, 프로세스를 어떻게 배치할지, 부족한 물리 메모리는 어떻게 처리할지

- 세그맨테이션
  - 메모리 관리자는 **세그멘테이션 테이블**을 이용하여 논리주소를 물리주소로 변환한다
    - 세그멘테이션 테이블: Base Address, Bound Address
  - CPU에서 논리주소를 전달해주면
  - 메모리관리자는 해당 논리주소가 몇번 세그먼트인지 알아낸다
  - 메모리 관리재 내의 Segment Table Base Register를 이용해서 물리매모리 내의 세그멘테이션 테이블을 찾고
  - 물리메모리 n번째의 세그멘테이션 테이블을 가져옴
  - 세그먼트 번호를 인덱스로 Base Address, Bound Address를 찾는다

    | 세그먼트 번호 | Base Address | Bound Address |
    | 0 | 1500 | 500 |
    | 1 | 5200 | 1000 |
    | 2 | 3700 | 1200 |
    | 2 | 6400 | 500 |

  - 이런 과정들을 거치므로 컨텍스트 스위칭은 매우 무거운 동작
  - Bound Address: 세그먼트의 크기
  - 메모리관리자는 CPU에서 받은 논리주소와 Bound Address를 비교
  - 논리주소가 Bound Address보다 작다면 논리주소와 Base Address를 더해 물리주소를 구하고
  - 논리주소가 Bound Address보다 크다면 메모리 침범으로 판단하고 에러 발생시킴
  - 장점
    - 메모리 가변적으로 분할
    - 코드영역, 데이터영역, 스택영역, 힙영역이 떨어져 있더라도 모듈로 묶어서 처리 가능
      - 공유, 메모리 접근 보호 편리
  - 단점
    - 외부 단편화

- 페이징
  - 일정한 크기로 나누어 외부단편화 현상이 일어나지 않는다
    - 대신 내부단편화 발생
  - 논리주소공간: 사용자와 프로세스가 바라보는 주소공간
    - 페이지: 논리주소공간을 일정한 크기로 균일하게 나눈것
  - 물리주소공간: 실제 메모리에서 사용되는 주소공간
    - 프레임: 물리주소공간을 일정한 크기로 균일하게 나눈것
  - 세그멘테이션과 마찬가지로 메모리관리자가 **페이지 테이블**을 가지고있다
  - CPU에서 논리주소를 전달해주면 메모리관리자가 몇 번 페이지의 오프셋 몇인지 알아낸다
  - 메모리관리자 내의 Page Table Base Register를 이용해서 물리 메모리의 페이지 테이블을 찾고

    | 인덱스(페이지 번호) | 프레임 |
    | 0 | 3 |
    | 1 | 1 |
    | 2 | invalid |
    | ... | ... |

  - 오프셋을 이용해 물리주소로 변환
  - invalid: 스왑 영역
  - 예시(32bit cpu)
    - 물리주소공간은 2GB로 가정
    - 가상 메모리 크기: 2의 32승 = 4GB (논리주소공간)
    - 크기가 2의 24승(16MB)인 페이지로 나누고 나머지 8bit는 페이지 번호를 나타낸다(256개의 페이지)
    - 물리주소공간도 16MB로 나눈다
    - 페이지 테이블은 1차원 테이블로 구성되어있다
    - CPU가 논리주소 0x1000번지에 접근한다고 가정
    - 페이지 넘버 = (논리주소 / 페이지 크기)의 몫
    - 1000 / 16777216(bit) = 0
    - 오프셋 = 논리주소 % 페이지 크기 = 1000
    - 페이지 테이블에서 0번 인덱스의 값을 가져온다 = 3
    - 프레임 3번 위치에서 오프셋 1000만큼 더해서 값을 구하면 물리주소 변환 끝

- **세그멘테이션(가변분할)과 페이징(고정분할) 의 차이**
  - 페이징
    - 논리주소공간을 나눈것은 페이지, 물리주소공간을 나눈것은 프레임
  - 세그멘테이션은 프로세스마다 크기가 달라 Bound Address가 필요하다
    - 외부단편화 발생
    - 논리적인 영역별로 세그먼트를 나눈다
      - 세그먼트마다 크기를 다르게 나눌 수 있으니 코드, 데이터, 스택, 힙 영역을 나눌 수 있다
  - 페이지는 크기가 일정하기 때문에 Bound Address가 필요하지 않다.
    - 내부단편화 발생(외부단편화보다 낫긴 하다)
    - 페이지 크기가 고정되어있어 논리적인 영역을 나눌 수 없다
      - 특정 영역을 떼어내서 공유하거나 권한 부여하기가 어렵다
    - 페이지 테이블(운영체제 영역)이 너무 커지면 사용자 영역이 부족하게 된다
      - 페이지 테이블을 적절히 유지하는것이 중요
  - 페이지드 세그멘테이션
    - 메모리 접근 권한: 메모리 특정 번지에 부여된 권한(R, W, E)
    - 프로세스는 코드, 데이터, 힙, 스택 영역 등이 있는데, 각 영역마다의 접근 권한이 있다
      - CODE: RE
      - DATA: R(W) // 전역변수, 상수 등
      - HEAP: RW
      - STACK: RW
    - 접근권한 검사는 가상주소 -> 물리주소 변환 시마다 일어난다
    - 세그멘테이션 테이블에 권한비트 추가

    | 세그먼트 번호 | 권한비트 | 페이지 넘버(개수) | 페이지 개수 |
    | 0 | RW | 2 | 500 |
    | 1 | RE | 0 | 1000 |
    | 2 | R | 1 | 1200 |
    | 2 | RWE | n | 500 |

    | 인덱스(페이지 번호) | 프레임 |
    | 0 | 3 |
    | 1 | 1 |
    | 2 | invalid |
    | ... | ... |

    - 세그멘테이션 테이블 확인 -> 권한 위반 검사 -> 페이지 넘버와 개수 가져옴 -> 페이지 테이블 접근 -> 프레임 번호 가져옴 -> 물리 메모리의 해당 프레임 접근 -> 그 위치에서 페이지 개수를 더해 물리주소를 구함 -> 물리메모리에 없다면 스왑영역에서 가져온다
    - 단점
      - 물리메모리에 접근하기 위해 메모리 접근을 두번 해야한다
      - 현대 운영체제: 페이징과 페이지드 세그멘테이션을 적절히 혼용

- 디맨드 페이징
  - 실제로는 프로세스의 코드, 데이터, 힙, 스택 등의 **일부만 메모리로 올라온다**
  - **90:10의 법칙**
    - 90% 시간이 10%의 코드를 동작시키는데 소비된다
    - **지역성 이론**
      - 공간의 지역성
        - 현재 위치에서 가까운 데이터에 접근할 확률이 높다
      - 시간의 지역성
        - 최근 접근했던 데이터에 다시 접근할 확률이 높다
      - goto문을 지양하는 이유 -> 지역성 이론 위배
    - 나머지는 스왑 영역으로
  - 디맨드 페이징: 사용할 데이터는 메모리로, 사용하지 않는 데이터는 스왑영역으로
    - 가상메모리는 곧 물리메모리와 스왑영역의 합
      - 스왑영역 전환은 오버헤드가 매우 크다
    - 스왑 인(메모리로 가져옴)
    - 스왑 아웃(메모리에서 스왑영역으로)
    - ex. 포토샵의 여러 필터들은 사용할 때 메모리에 올라온다
  - 메모리 관리자는 페이지 테이블을 이용하여 물리메모리의 프레임이나 스왑영역의 위치를 구한다
    - 이를 위해 페이지 테이블에는 여러가지 비트들이 있다

    | 인덱스(페이지 번호) | 프레임 |
    | 0 | 3 |
    | 1 | 1 |
    | 2 | invalid |

  - 페이지 테이블 엔트리, PTE
    - 페이지 테이블의 한 행
      - 프레임 넘버 말고도 다양한 정보들이 있다
      - 접근비트, 변경비트, 유효비트, RWE비트, 프레임
      - 접근이 있었는지, 변경이 있었는지, 이 페이지가 물리메모리 or 스왑영역 어디에 있는건지, 접근권한은 어떤지 등등…
    - 프로세스가 특정 주소에 접근하려 할 때, 필요한 페이지가 스왑영역에 있다면 (물리메모리에 없다면)
      - 프로세스를 잠시 중지(Page Fault) → 스왑영역 페이지를 메모리로 올림 → 다시 실행
    - 그럼 어떻게 스왑인 스왑아웃을 하나? → 페이지 교체 정책

- 페이지 교체 정책
  - Page fault가 발생하면 해당 페이지를 스왑 영역에서 메모리로 불러들여야 한다.
  - 메모리가 꽉 차서 공간이 없다면, 메모리에 있는 페이지 중 하나를 선택해서 스왑영역으로 옮겨야 한다.
  - 방법1 - 무작위
    - 지역성 고려 x, 자주 사용되는 페이지가 교체될 가능성이 있다
    - 거의 사용되지 않음
  - 방법2 - FIFO, 가장 오래된 페이지 교체
    - 자주 사용되는 페이지가 교체될 가능성이 있지만 구현이 간단, 수정하여 사용
      - 2차 기회 페이지 교체 알고리즘
        - 자주 사용하는 페이지에 추가 기회 부여 → Page Fault 없이 조회 성공했다면 큐의 맨 뒤로 이동
    - 빌레이디의 역설
      - Page Fault를 줄이려고 메모리를 더 늘려서 프레임의 수를 늘렸는데 오히려 더 많이 발생하는 현상
      - LRU에서는 발생하지 않는다
  - 방법3 - Optimum, 가장 사용하지 않을 페이지 교체
    - 이론적인 방법 (성능 비교용)
  - 방법4 - LRU, Least Recently Used
    - 시간의 지역성 활용
    - 시간을 표현하려면 PTE에 많은 비트가 필요하고, 구현이 힘드며, 시간이 오래 지나면 오버플로우로 초기화 될 가능성이 있다
      - 클락 알고리즘으로 유사하게 구현
        - 접근비트 하나만 이용

- 스레싱
  - 운영체제는 프로세스를 늘려 멀티프로그래밍으로 CPU 사용량을 최대로 뽑으려 한다
  → 그만큼 메모리에 많은 프레임 필요
  → 실행되지 않는 프레임들은 스왑영역으로
  → 잦은 Page fault 발생 → CPU 작업시간보다 스왑 작업시간이 더 길어짐
  → CPU 사용률 하락 → CPU 스케줄러가 더 많은 프로세스 실행 → 반복
  - 원인 : 물리메모리 크기 부족
    - 하드웨어적 해결
      - 램을 늘려 스레싱 발생 시점을 늦춘다
      - 스레싱이 발생하지 않는다면, 메모리 늘려도 성능향상은 크지 않다
    - 소프트웨어적 해결
      - 너무 많은 페이지를 할당하면 다른 프로세스가 할당받을 페이지가 감소해 효율 하락
      - 너무 적은 페이지를 할당하면 잦은 Page fault → 잦은 스왑요청 → 스레싱 발생
      - 프로세스가 실행하면 일정량의 페이지를 할당하고,
      Page fault가 발생하면 더 많은 페이지 할당. 반대로도 조절
      - 어떤 페이지를 유지할 것인지는 지역성 이론 활용
        - 워킹셋 - 현재 메모리에 올라와있는 페이지들을 세트로 묶어두고, 컨택스트 스위칭 시 활용