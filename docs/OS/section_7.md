---
layout: default
title: 7. 가상메모리
parent: OS
---

# 가상메모리
{: .no_toc }

1. TOC
{:toc}

### 섹션7 가상메모리

- 가상메모리는 이론상으로 무한대지만, 실제로는 물리메모리 크기와 CPU의 비트수로 결정된다.
  - 32bit인 경우, 표현 가능 주소값은 최대 2의 32승
- 동적주소변환 = 메모리 관리자가 메모리 + 하드디스크 스왑영역을 합쳐서 주소를 다루는 것
- 세그멘테이션과 페이징
  - 페이징
    - 논리주소공간을 나눈것은 페이지, 물리주소공간을 나눈것은 프레임
  - 세그멘테이션은 프로세스마다 크기가 달라 Bound Address가 필요하다
    - 외부단편화 발생
  - 페이지는 크기가 일정하기 때문에 Bound Address가 필요하지 않다.
    - 내부단편화 발생
- 페이지드 세그멘테이션도 있다.
- 디맨드 페이징
  - 실제로는 프로세스의 코드, 데이터, 힙, 스택 등의 일부만 올라온다
    - 나머지는 스왑 영역으로
    - 스왑 인(메모리로 가져옴), 스왑 아웃(메모리에서 스왑영역으로)
  - 지역성 이론
    - 공간의 지역성
      - 현재 위치와 가까운 데이터에 접근할 확률 높음
    - 시간의 지역성
      - 최근 접근한 데이터가 오래된 데이터보다 접근 확률 높음
  - 페이지 테이블 엔트리, PTE
    - 페이지마다 다양한 정보들이 있다
      - 접근이 있었는지, 변경이 있었는지, 이 페이지가 물리메모리에 있는건지, 접근권한은 어떤제 등등…
    - 프로세스가 특정 주소에 접근하려 할 때, 필요한 페이지가 스왑영역에 있다면
    프로세스를 잠시 중지 → 스왑영역 페이지를 메모리로 올림 → 다시 실행
    - 그럼 어떻게 스왑인 스왑아웃을 하나? → 페이지 교체 정책
- 페이지 교체 정책
  - Page fault가 발생하면 해당 페이지를 스왑 영역에서 메모리로 불러들여야 한다.
  - 메모리가 꽉 차서 공간이 없다면, 메모리에 있는 페이지 중 하나를 선택해서 스왑영역으로 옮겨야 한다.
  - 방법1 - 무작위
    - 지역성 고려 x, 자주 사용되는 페이지가 교체될 가능성이 있다
    - 방법2 - FIFO, 가장 오래된 페이지 교체
      - 자주 사용되는 페이지가 교체될 가능성이 있지만 구현이 간단, 수정하여 사용
        - 자주 사용하는 페이지에 추가 기회 부여 → 큐의 맨 뒤로 이동
  - 방법3 - Optimum, 가장 사용하지 않을 페이지 교체
    - 이론적인 방법, 성능 비교용
  - 방법4 - LRU, Least Recently Used
    - 시간의 지역성 활용
    - 시간을 표현하려면 PTE에 많은 비트가 필요하고, 오버플로우 가능성이 있다
      - 클락 알고리즘으로 유사하게 구현
- 스레싱
  - 운영체제는 프로세스를 늘려 멀티프로그래밍으로 CPU 사용량을 최대로 뽑으려 한다
  → 그만큼 메모리에 많은 프레임 필요
  → 실행되지 않는 프레임들은 스왑영역으로
  → 잦은 Page fault 발생 → CPU 작업시간보다 스왑 작업시간이 더 길어짐
  → CPU 사용률 하락 → CPU 스케줄러가 더 많은 프로세스 실행 → 반복
  - 원인 : 물리메모리 크기 부족
    - 하드웨어적 해결
      - 램을 늘려 스레싱 발생 시점을 늦춘다
      - 스레싱이 발생하지 않는다면, 메모리 늘려도 성능향상은 크지 않다
    - 소프트웨어적 해결
      - 너무 많은 페이지를 할당하면 다른 프로세스가 할당받을 페이지가 감소해 효율 하락
      - 너무 적은 페이지를 할당하면 잦은 Page fault → 잦은 스왑요청 → 스레싱 발생
      - 프로세스가 실행하면 일정량의 페이지를 할당하고,
      Page fault가 발생하면 더 많은 페이지 할당. 반대로도 조절
      - 어떤 페이지를 유지할 것인지는 지역성 이론 활용
        - 워킹셋 - 현재 메모리에 올라와있는 페이지들을 세트로 묶어두고, 컨택스트 스위칭 시 활용