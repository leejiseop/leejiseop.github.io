---
layout: default
title: 6. 메모리
parent: OS
---

# 메모리
{: .no_toc }

1. TOC
{:toc}

### 섹션6 메모리

- 레지스터 - 캐시 - 메인메모리 - 보조저장장치
    - 레지스터 - CPU 내의 저장장치
        - 32bit, 64bit
    - 캐시
        - L1, L2 …
- 폰 노이만 구조 - 프로그램을 메모리에 올려 실행
- 주소 - 운영체제가 메모리 관리를 위해 메모리를 1바이트 크기로 구역을 나누고 숫자를 매긴 것
- 32bit CPU와 64bit CPU
    - 레지스터 크기, ALU, 데이터 버스의 크기
    - 64bit가 한번에 처리 가능한 양이 많기 때문에 속도가 더 빠르다
    - 다룰 수 있는 메모리
        - 2의 32승 = 4GB
        - 2의 64승 = 사실상 무한대
- 경계 레지스터 - 메모리 관리자가 사용자 프로세스가 경계 레시스터의 값을 벗어났는지 검사
    - 벗어났다면, 프로세스를 종료
- 상대주소와 절대주소
    - 상대주소(논리주소) - 컴파일러는 0번지로 가정하여 프로그램을 만든다
    - 절대주소(물리주소) - 실제 메모리가 할당된 주소
- 메모리 할당방식
- 메모리보다 더 큰 프로그램을 실행시키려면
    - 메모리 오버레이 - 당장 실행시킬 부분만 메모리에 적재, 나머지는 보조저장장치의 스왑영역에 저장
- 멀티프로그래밍에선 영역을 어떻게 나눌까?
    - 가변 분할 방식 (세그멘테이션)
        - 프로세스의 크기에 따라 메모리를 나눈다
        - 프로세스들이 연속적으로 할당되기 때문에 ‘연속 메모리 할당’ 이라고 한다.
            - 내부 단편화가 없지만, 외부 단편화 발생
            - 프로세스가 종료되면 빈 공간이 생기지만, 연속된 공간이 아니기 때문에 빈공간이 충분해도 새로운 프로세스가 할당되지 못한다.
                - 조각모음 - 모든 프로세스 일시정지 및 메모리 이동 오버헤드 발생
    - 고정 분할 방식 (페이징)
        - 프로세스의 크기와 상관없이 메모리를 정해진 크기로 나눈다
        - 메모리를 2MB로 분할하면, 5MB 프로세스는 구역 세 개에 나눠서 할당
        - 메모리에 분산되어 할당되기 때문에 ‘비연속 메모리 할당’이라고 한다.
            - 구현이 간단하고 오버헤드가 적지만, 내부 단편화 발생
                - 메모리가 부족하면 스왑영역 활용
                - 내부 단편화를 줄이려면 분할 크기를 줄인다
    - 버디 시스템 (가변 + 고정)
        - 2의 승수로 메모리를 분할
            - 가변분할처럼 프로세스 크기에 따라 할당되는 메모리 크기가 달라지고
            - 외부 단편화를 방지하기 위해 메모리 공간을 확보하는 것이 간단
            - 고정분할 방식처럼 내부단편화가 발생하기는 하지만 최소화